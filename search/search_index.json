{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"REST-Backend f\u00fcr einen Webshop \u2014 Einleitung","text":"<p>Lernfeld 8 \u2013 Arbeitsblatt</p> <p>Thema: REST-Backend f\u00fcr einen Webshop Technologien &amp; Inhalte: Docker, PostgreSQL-Datenbank, Implementierung von 1:1- und 1:n\u2011Beziehungen zwischen Entit\u00e4tsklassen, Validierung von Entity\u2011Objekten, DTOs, Mapping, Services</p>"},{"location":"#ziel-des-tutorials","title":"Ziel des Tutorials","text":"<p>Anwendungen bestehen in der Regel aus mehreren Klassen, deren Objekte mit ihren Beziehungen untereinander persistiert werden m\u00fcssen. In der folgenden \u00dcbung soll das unten abgebildete Datenmodell f\u00fcr einen Webshop als REST\u2011Backend implementiert werden.</p> <ul> <li>Ein Lieferant (Supplier) hat einen Kontakt (Contact) und ein Kontakt geh\u00f6rt immer jeweils zu einem Lieferanten. Es handelt sich um eine bidirektionale Assoziation (beide Klassen referenzieren sich).</li> <li>Zwischen Supplier und Article besteht ebenfalls eine bidirektionale Assoziation mit anderer Multiplizit\u00e4t: Ein Lieferant kann beliebig viele Artikel liefern (1:n), ein Artikel wird nur von einem Lieferanten geliefert.</li> <li>Die Klasse Supplier soll die zu liefernden Artikel in einem Set referenzieren.</li> </ul> <p>Die Implementierung umfasst: - Aufsetzen und Konfigurieren eines Spring\u2011Boot\u2011Projekts mit PostgreSQL (in Docker) - Modellierung der Entit\u00e4ten und ihrer Beziehungen (JPA/Hibernate) - Validierung (Bean Validation) - Entkopplung \u00fcber DTOs und einen Mapping\u2011Service - Services f\u00fcr Businesslogik - REST\u2011Controller mit CRUD\u2011Endpunkten - Integrationstests (Testcontainers) - Zentrales Exception\u2011Handling - Erweiterungen (z.\u202fB. HATEOAS)</p> <pre><code>classDiagram\n    class Supplier {\n        - id: Long\n        - name: String\n        - contact: Contact\n        - articles: Set&lt;Article&gt;\n    }\n\n    class Contact {\n        - id: Long\n        - street: String\n        - postcode: String\n        - city: String\n        - phone: String\n        - supplier: Supplier\n    }\n\n    class Article {\n        - id: Long\n        - designation: String\n        - price: Double\n        - createDate: LocalDateTime\n        - lastUpdateDate: LocalDateTime\n        - supplier: Supplier\n    }\n\n    Supplier \"1\" --&gt; \"1\" Contact : contact\n    Supplier \"1\" --&gt; \"*\" Article : articles</code></pre>"},{"location":"01_Docker_Postgres/","title":"Aufsetzen und Konfigurieren: Docker + PostgreSQL","text":"<p>Statt der In\u2011Memory\u2011Datenbank H2 soll in diesem Tutorial die professionelle und Open\u2011Source\u2011Datenbank PostgreSQL verwendet werden. Wir setzen keinen separaten DB\u2011Server auf, sondern betreiben PostgreSQL in einem Docker\u2011Container. Daf\u00fcr sind ein paar zus\u00e4tzliche Konfigurationen n\u00f6tig.</p> <p>Erstelle ein neues Spring\u2011Boot\u2011Projekt mit dem Bezeichner <code>store</code>. Group: <code>de.szut</code>. Ben\u00f6tigte Abh\u00e4ngigkeiten: Spring Web, Spring Data JPA, Lombok, PostgreSQL Driver.</p> <p>Erstelle im Hauptverzeichnis deines Projekts (auf Root-Ebene) die Datei <code>compose.yml</code>.</p> <p>In der Regel bilden mehrere Docker\u2011Container eine Anwendung. Docker Compose dient dazu, mehrere Images zu konfigurieren und hintereinander zu starten (anstatt jeden Container einzeln). In unserem Fall ben\u00f6tigen wir nur einen Container: die PostgreSQL\u2011Datenbank.</p> <p>Kopiere den unten abgebildeten Code in dein Compose\u2011File:</p> <pre><code>volumes:\n  store_postgres_data:\n    driver: local\n\nservices:\n  postgres_for_store:\n    container_name: store_postgres_container\n    image: postgres:16\n    volumes:\n      - store_postgres_data:/var/lib/postgresql/data\n    environment:\n      POSTGRES_DB: store_db\n      POSTGRES_USER: store\n      POSTGRES_PASSWORD: secret\n    ports:\n      - \"5432:5432\"\n</code></pre> <p>Erl\u00e4uterungen: - Unter <code>services</code> werden Container erstellt/konfiguriert. Unser Container hei\u00dft <code>store_postgres_container</code> und basiert auf <code>postgres:16</code> (Download aus Docker Hub). - Unter <code>environment</code> setzen wir DB\u2011Name, Benutzer und Passwort innerhalb des Containers. - Unter <code>ports</code> wird der Host\u2011Port 5432 auf den Container\u2011Port 5432 gemappt (Standard\u2011Port f\u00fcr PostgreSQL). - Damit Daten persistent bleiben, definieren wir ein Volume (<code>store_postgres_data</code>) und mounten es auf den Datenpfad des Containers (<code>/var/lib/postgresql/data</code>).</p>"},{"location":"01_Docker_Postgres/#startenstoppen","title":"Starten/Stoppen","text":"<ol> <li>Docker starten.  </li> <li>Im Terminal (z. B. IntelliJ) im Projekt-Root-Verzeichnis ausf\u00fchren:</li> <li>Starten: <code>docker compose up</code> </li> <li>Erfolgreich, wenn im Log steht: \"database system is ready to accept connections\".  </li> <li>Optional mit <code>-d</code> f\u00fcr Detached-Modus (Hintergrund): <code>docker compose up -d</code></li> <li>Beenden: <code>docker compose down</code> </li> <li>Volume ggf. l\u00f6schen: <code>docker volume rm store_postgres_data</code></li> </ol>"},{"location":"02_SpringBoot_Config/","title":"Spring Boot \u2013 Datenbankkonfiguration","text":"<p>Als n\u00e4chstes muss unsere Spring\u2011Boot\u2011Anwendung mit der PostgreSQL\u2011Datenbank bekannt gemacht werden. \u00d6ffne dazu die Datei <code>application.properties</code> und kopiere folgende Konfiguration hinein:</p> <pre><code>spring.datasource.url=jdbc:postgresql://localhost:5432/store_db\nspring.datasource.username=store\nspring.datasource.password=secret\nserver.port=8080\nspring.jpa.hibernate.ddl-auto=create-drop\n</code></pre> <p>Erl\u00e4uterungen: - Zeilen 1\u20133: Verbindung zur lokalen Datenbank (URL, Nutzer, Passwort). - <code>server.port=8080</code>: Der Webservice ist auf Port 8080 erreichbar. - <code>spring.jpa.hibernate.ddl-auto=create-drop</code>: W\u00e4hrend der Entwicklung wird bei jedem Neustart eine neue DB angelegt.</p> <p>Test: Starte deinen Docker\u2011Container und danach den Webservice. Beide sollten fehlerfrei laufen. Fahre beide wieder herunter.</p>"},{"location":"03_Models/","title":"Implementierung der Models","text":"<p>F\u00fcr die Validierung unserer Modelklassen ben\u00f6tigen wir eine weitere Abh\u00e4ngigkeit. F\u00fcge daher in der <code>build.gradle.kts</code> die folgende Abh\u00e4ngigkeit am Ende des Dependencies\u2011Bereichs hinzu:</p> <pre><code>implementation(\"org.springframework.boot:spring-boot-starter-validation\")\n</code></pre> <p>Bisher haben wir eine Package\u2011Struktur gew\u00e4hlt, die die Dateien nach ihrer Schicht innerhalb der Anwendung sortiert hat: <code>controller</code>, <code>model</code>, <code>repository</code>. Das ist im Prinzip auch in Ordnung. Beim Entwickeln gr\u00f6\u00dferer Anwendungen kann es aber nerven, st\u00e4ndig zwischen den Packages hin und her wechseln zu m\u00fcssen, sobald man \u00c4nderungen an einem Modul vornimmt, weil sich der Controller, das Model, wom\u00f6glich verschiedene Services und das Repository in unterschiedlichen Packages befinden. Wir w\u00e4hlen daher dieses Mal eine Sortierung nach Modulen. Erstelle daher erst einmal die Packages <code>supplier</code>, <code>article</code> und <code>contact</code>.</p> <p>Um den Zweck der Modelklassen im Namen deutlicher hervorzuheben, h\u00e4ngen wir an jede Modelklassenbezeichnung das W\u00f6rtchen Entity an. Das erleichtert noch einmal die Suche nach unseren Klassen in der neuen Package\u2011Struktur.</p>"},{"location":"03_Models/#contactentity","title":"ContactEntity","text":"<p>Implementiere im Package <code>contact</code> eine Klasse mit dem Bezeichner <code>ContactEntity</code>. Lasse Konstruktoren, Getter und Setter von Lombok generieren. Annotiere analog zur letzten \u00dcbung die Klasse, so dass sie von Spring Data in einem Datenbankmodell abgebildet wird. Benutze f\u00fcr die automatische Generierung des Prim\u00e4rschl\u00fcssels dieses Mal die Strategie IDENTITY. Sie bewirkt, dass nicht mehr die angelegten Entit\u00e4ten egal welchen Typs von 1 beginnend, sondern die Entit\u00e4ten jeder einzelnen Tabelle beginnend mit 1 durchgez\u00e4hlt werden.</p> <p>Um die Standardbezeichnungen von Hibernate zu umgehen und Kontaktobjekte sp\u00e4ter validieren zu k\u00f6nnen, erh\u00e4lt die Klasse <code>ContactEntity</code> weitere Annotationen. Zum einen soll es nicht m\u00f6glich sein, Kontaktdaten mit null\u2011Werten anzulegen. Es sollen nur vollst\u00e4ndige Adressen mit Angabe der Stra\u00dfe, der Postleitzahl und des Ortes akzeptiert werden, wobei die L\u00e4nge der Stra\u00dfen\u2011 und der Ortangabe 50 Zeichen nicht \u00fcberschreiten darf. Zum anderen soll die Datenbanktabelle f\u00fcr den Kontakt nicht den Bezeichner der Klasse haben, sondern \u201esupplier_contact\u201c hei\u00dfen. Au\u00dferdem soll die Spalte f\u00fcr die Postleitzahl mit der englischen Abk\u00fcrzung \u201ezip\u201c bezeichnet werden. Annotiere die Klasse daher wie unten abgebildet.</p> <pre><code>@Entity\n@Table(name = \"supplier_contact\")\n@Getter\n@Setter\n@NoArgsConstructor\npublic class ContactEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long cid;\n\n    @NotBlank(message = \"Street is mandatory\")\n    @Size(max = 50)\n    private String street;\n\n    @NotBlank(message = \"Postcode is mandatory\")\n    @Column(name = \"zip\")\n    private String postcode;\n\n    @NotBlank(message = \"City is mandatory\")\n    @Size(max = 50)\n    private String city;\n\n    @NotBlank(message = \"Phone is mandatory\")\n    private String phone;\n}\n</code></pre> <p>Hinweis: Falls IntelliJ die neuen Annotationen mit \u201eCannot resolve table 'supplier_contact'\u201c markiert, siehe: https://stackoverflow.com/questions/58666411/cannot-resolve-table-xx-in-spring-boot-application</p> <p>Statt <code>@NotBlank</code> k\u00f6nnten auch <code>@NotNull</code> oder <code>@NotEmpty</code> verwendet werden. <code>@NotNull</code> verhindert lediglich <code>null</code>, <code>@NotEmpty</code> verlangt L\u00e4nge &gt; 0, <code>@NotBlank</code> verhindert dar\u00fcber hinaus nur Leerzeichen.</p>"},{"location":"03_Models/#supplierentity","title":"SupplierEntity","text":"<p>Implementiere analog zu <code>ContactEntity</code> die Klasse <code>SupplierEntity</code>. Beachte: Die Datenbanktabelle soll <code>supplier</code> hei\u00dfen und der Name ist Pflichtfeld (max. 50 Zeichen).</p> <pre><code>@Entity\n@Table(name = \"supplier\")\n@Getter\n@Setter\n@NoArgsConstructor\npublic class SupplierEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long sid;\n\n    @NotBlank(message = \"Name is mandatory\")\n    @Size(max = 50)\n    private String name;\n\n    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\n    private ContactEntity contact;\n\n    @OneToMany(mappedBy = \"supplier\",\n               fetch = FetchType.LAZY)\n    private Set&lt;ArticleEntity&gt; articles = new HashSet&lt;&gt;();\n}\n</code></pre>"},{"location":"03_Models/#articleentity","title":"ArticleEntity","text":"<p>Implementiere die Klasse <code>ArticleEntity</code> wie unten angegeben. Die Attribute <code>designation</code> und <code>price</code> sind Pflichtwerte. Beachte die verwendeten Lombok\u2011Annotationen <code>@Getter</code>, <code>@Setter</code> und <code>@NoArgsConstructor</code>, die anstelle der <code>@Data</code> verwendet wurden. <code>@Data</code> \u00fcberschreibt u.\u202fa. <code>hashCode()</code> und f\u00fchrt hier sp\u00e4ter zu Fehlern in Hibernate.</p> <pre><code>@Entity\n@Table(name = \"article\")\n@Getter\n@Setter\n@NoArgsConstructor\npublic class ArticleEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long aid;\n\n    @NotBlank(message = \"Designation is mandatory\")\n    private String designation;\n\n    @NotNull(message = \"Price is mandatory\")\n    private Double price;\n\n    private LocalDateTime createDate;\n    private LocalDateTime lastUpdateDate;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    private SupplierEntity supplier;\n}\n</code></pre>"},{"location":"04_Bidirektionale_Assoziationen/","title":"Bidirektionale Assoziationen &amp; Lazy/Eager Loading","text":"<p>Hibernate mapped die Beziehungen unseres Klassenmodells auf die Beziehungen einer relationalen Datenbank.</p>"},{"location":"04_Bidirektionale_Assoziationen/#11-supplierentity-contactentity","title":"1:1 \u2013 SupplierEntity \u2194 ContactEntity","text":"<p>Zwischen <code>SupplierEntity</code> und <code>ContactEntity</code> besteht eine 1:1\u2011Beziehung. In relationalen DBs wird eine 1:1 so umgesetzt, dass der Prim\u00e4rschl\u00fcssel einer Tabelle als Fremdschl\u00fcssel in der anderen aufgenommen wird. Welche Tabelle den FK erh\u00e4lt, ist frei w\u00e4hlbar.</p> <p>In unserem Datenmodell geben wir die 1:1\u2011Beziehung \u00fcber <code>@OneToOne</code> an:</p> <pre><code>public class SupplierEntity {\n    \u2026\n    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\n    private ContactEntity contact;\n}\n</code></pre> <pre><code>public class ContactEntity {\n    \u2026\n    @OneToOne(mappedBy = \"contact\", fetch = FetchType.LAZY)\n    private SupplierEntity supplier;\n}\n</code></pre> <p>Da Hibernate wissen muss, in welcher Tabelle der Fremdschl\u00fcssel eingef\u00fcgt werden soll, deklarieren wir \u00fcber <code>mappedBy</code> den Eigent\u00fcmer der Beziehung. Das Mapping bewirkt, dass Hibernate in der Tabelle <code>supplier</code> statt eines eingebetteten Objekts einen Fremdschl\u00fcssel einf\u00fcgt (Default\u2011Benennung <code>contact_id</code>).</p>"},{"location":"04_Bidirektionale_Assoziationen/#hinweis-zu-cascading","title":"Hinweis zu Cascading","text":"<p><code>cascade = CascadeType.ALL</code> sorgt daf\u00fcr, dass Speichern/\u00c4ndern/L\u00f6schen vom Supplier auf Contact kaskadiert wird. Das ist hier sinnvoll, da <code>ContactEntity</code>  nur als Teil eines Suppliers existieren soll und ohne ihn keine eigenst\u00e4ndige Bedeutung hat.</p> <p>Wichtig: Cascading sollte nur auf der Eigent\u00fcmer-Seite (<code>SupplierEntity</code>) definiert werden, nicht auf der <code>mappedBy</code>-Seite. Die nicht-besitzende Seite (<code>ContactEntity</code>) sollte kein Cascading haben, um unerw\u00fcnschte Effekte zu vermeiden.</p>"},{"location":"04_Bidirektionale_Assoziationen/#lazy-loading-vs-eager-loading","title":"Lazy Loading vs. Eager Loading","text":"<ul> <li>Eager Loading: Verbundene Objekte einer Beziehung werden sofort geladen.</li> <li>Lazy Loading: Verbundene Objekte werden bei Bedarf nachgeladen (beim ersten Zugriff).</li> </ul> <p>Per Voreinstellung gilt Lazy Loading. Vorteile: Speicher &amp; Performance (nur wirklich ben\u00f6tigte Objekte). Hibernate implementiert Lazy via Proxy (Stellvertreter\u2011Objekt mit gleicher Schnittstelle, das beim ersten Methodenaufruf das Ziel l\u00e4dt).</p>"},{"location":"04_Bidirektionale_Assoziationen/#1n-supplierentity-articleentity","title":"1:n \u2013 SupplierEntity \u2194 ArticleEntity","text":"<p>Zwischen <code>SupplierEntity</code> und <code>ArticleEntity</code> besteht eine 1:n\u2011Beziehung. Ein Lieferant liefert 0..n Artikel; ein Artikel geh\u00f6rt hier genau zu einem Lieferanten.</p> <p>In der relationalen Abbildung erh\u00e4lt die n\u2011Seite den FK. In Java gen\u00fcgt auf der n\u2011Seite:</p> <pre><code>@Entity\npublic class ArticleEntity {\n    \u2026\n    @ManyToOne(fetch = FetchType.LAZY)\n    private SupplierEntity supplier;\n}\n</code></pre> <p>Die obige Annotation w\u00fcrde eine unidirektionale Assoziation implementieren (nur Artikel kennt seinen Lieferanten). Wir wollen sie bidirektional: Supplier kennt seine Artikel.</p> <p>Erg\u00e4nze daher in <code>SupplierEntity</code>:</p> <pre><code>@OneToMany(mappedBy = \"supplier\", fetch = FetchType.LAZY)\nprivate Set&lt;ArticleEntity&gt; articles = new HashSet&lt;&gt;();\n</code></pre> <p>Wichtig ist <code>mappedBy = \"supplier\"</code>. In einer bidirektionalen Beziehung muss eine Seite der Eigent\u00fcmer sein. Aus Performance\u2011Gr\u00fcnden w\u00e4hlt man fast immer die @ManyToOne\u2011Seite (hier: <code>ArticleEntity</code>) als Eigent\u00fcmer.</p>"},{"location":"04_Bidirektionale_Assoziationen/#warnung-kein-cascading-bei-1n-beziehungen","title":"\u26a0\ufe0f Warnung: Kein Cascading bei 1:n-Beziehungen!","text":"<p>Warum hier KEIN <code>cascade = CascadeType.ALL</code>?</p> <p>Bei 1:n-Beziehungen ist <code>CascadeType.ALL</code> meist problematisch:</p> <ol> <li> <p>Ungewolltes L\u00f6schen: Wird ein <code>SupplierEntity</code> gel\u00f6scht, w\u00fcrden automatisch alle zugeh\u00f6rigen Artikel gel\u00f6scht. In der Praxis m\u00f6chte man oft die Artikel behalten und einem anderen Lieferanten zuordnen oder separat verwalten.</p> </li> <li> <p>Ungewollte Nebeneffekte: Beim Speichern/Aktualisieren eines Suppliers w\u00fcrden automatisch alle Artikel mit gespeichert/aktualisiert, auch wenn das nicht beabsichtigt ist.</p> </li> <li> <p>Fehlende Kontrolle: Die Logik f\u00fcr das Verwalten von Artikeln sollte explizit \u00fcber den <code>ArticleRepository</code> oder einen Service erfolgen.</p> </li> </ol> <p>Best Practice f\u00fcr 1:n-Beziehungen: - Keine Cascade-Operationen (wie oben) ODER - Nur spezifische Operationen wie <code>cascade = {CascadeType.PERSIST, CascadeType.MERGE}</code>, falls wirklich ben\u00f6tigt - Artikel explizit \u00fcber ihren eigenen Repository verwalten</p> <p>Faustregel: Cascading nur bei Komposition (Teil-von-Beziehung), nicht bei Assoziation (eigenst\u00e4ndige Entities).</p>"},{"location":"05_Repositories/","title":"Implementierung der Repositories","text":"<p>Implementiere die Datenzugriffsschicht, indem du f\u00fcr <code>ArticleEntity</code> und <code>SupplierEntity</code> im jeweiligen Modul\u2011Package ein Repository implementierst. (Warum kein <code>ContactRepository</code> ben\u00f6tigt wird, wird sp\u00e4ter diskutiert.)</p> <p>Hinweis: Du musst nur jeweils ein Interface anlegen, das <code>JpaRepository</code> erweitert.</p> <p>Beispiel:</p> <pre><code>public interface SupplierRepository extends JpaRepository&lt;SupplierEntity, Long&gt; { }\n</code></pre> <pre><code>public interface ArticleRepository extends JpaRepository&lt;ArticleEntity, Long&gt; { }\n</code></pre>"},{"location":"05_Repositories/#was-bewirkt-das-erweitern-von-jparepository","title":"Was bewirkt das Erweitern von JpaRepository?","text":"<p>Durch das Erweitern von <code>JpaRepository&lt;SupplierEntity, Long&gt;</code> erh\u00e4lt das Repository automatisch eine Vielzahl von CRUD-Operationen (Create, Read, Update, Delete), ohne dass du diese Methoden selbst implementieren musst:</p> <ul> <li><code>save(entity)</code> \u2013 Speichert oder aktualisiert eine Entity</li> <li><code>findById(id)</code> \u2013 Findet eine Entity anhand ihrer ID</li> <li><code>findAll()</code> \u2013 Gibt alle Entities zur\u00fcck</li> <li><code>deleteById(id)</code> \u2013 L\u00f6scht eine Entity anhand ihrer ID</li> <li><code>count()</code> \u2013 Z\u00e4hlt die Anzahl der Entities</li> <li><code>existsById(id)</code> \u2013 Pr\u00fcft, ob eine Entity mit der ID existiert</li> <li>und viele weitere...</li> </ul> <p>Die generischen Typparameter <code>&lt;SupplierEntity, Long&gt;</code> geben an: 1. <code>SupplierEntity</code>: Die Entity-Klasse, die verwaltet wird 2. <code>Long</code>: Der Datentyp des Prim\u00e4rschl\u00fcssels (@Id-Feld)</p> <p>Spring Data JPA generiert zur Laufzeit automatisch eine Implementierung dieses Interfaces, die alle SQL-Queries f\u00fcr diese Standard-Operationen erzeugt und ausf\u00fchrt. Das Repository kann dann einfach per Dependency Injection in Services oder Controller verwendet werden.</p>"},{"location":"06_DTOs_und_Mapping/","title":"DTOs und Mapping","text":"<p>In fr\u00fcheren \u00dcbungen wurden Entity\u2011Objekte direkt in JSON serialisiert/deserialisiert. Das koppelt jedoch Controller und Persistenzstruktur sehr eng. \u00c4nderungen an der DB\u2011Struktur erzwingen API\u2011\u00c4nderungen (und umgekehrt). Best Practice ist daher die Entkopplung \u00fcber DTOs (Data Transfer Objects) und ein Mapping zwischen DTOs und Entities.</p>"},{"location":"06_DTOs_und_Mapping/#warum-sind-dtos-wichtig","title":"Warum sind DTOs wichtig?","text":""},{"location":"06_DTOs_und_Mapping/#1-entkopplung-von-api-und-datenbank","title":"1. Entkopplung von API und Datenbank","text":"<p>Ohne DTOs sind die Endpunkt-Strukturen direkt an die Datenbankstruktur gebunden. Jede \u00c4nderung am Datenbankmodell (z.B. Umbenennung, neue Felder) w\u00fcrde die API brechen und alle Clients zwingen, ihre Integration anzupassen. Mit DTOs k\u00f6nnen API und Datenbank unabh\u00e4ngig voneinander evolvieren.</p>"},{"location":"06_DTOs_und_Mapping/#2-vermeidung-von-lazy-loading-problemen","title":"2. Vermeidung von Lazy-Loading-Problemen","text":"<p>Entities enthalten oft bidirektionale Beziehungen und Lazy-Loading. Wird eine Entity direkt serialisiert, kann das zu: - LazyInitializationException f\u00fchren (au\u00dferhalb der Transaktion) - Zirkul\u00e4ren Referenzen f\u00fchren (JSON-Serialisierung schl\u00e4gt fehl)</p> <p>DTOs enthalten nur die wirklich ben\u00f6tigten Daten ohne Beziehungen.</p>"},{"location":"06_DTOs_und_Mapping/#3-sicherheit-und-datenschutz","title":"3. Sicherheit und Datenschutz","text":"<p>Entities enthalten oft interne Felder, die nicht nach au\u00dfen gegeben werden sollen: - Passwort-Hashes - Interne IDs oder Referenzen - Zeitstempel wie <code>lastUpdateDate</code>, <code>createdBy</code> - Soft-Delete-Flags</p> <p>Mit DTOs kontrollierst du explizit, welche Daten exponiert werden.</p>"},{"location":"06_DTOs_und_Mapping/#4-api-design-nach-use-cases","title":"4. API-Design nach Use-Cases","text":"<p>Verschiedene Endpunkte ben\u00f6tigen verschiedene Datenstrukturen: - GET /suppliers \u2192 Liste mit Basis-Info (ohne Details) - GET /suppliers/{id} \u2192 Vollst\u00e4ndige Details inkl. Kontakt - POST /suppliers \u2192 Eingabe-DTO mit Validierung - GET /suppliers/{id}/articles \u2192 Supplier mit zugeh\u00f6rigen Artikeln</p> <p>Ein DTO pro Use-Case macht die API klar und effizient.</p>"},{"location":"06_DTOs_und_Mapping/#5-validierung-auf-api-ebene","title":"5. Validierung auf API-Ebene","text":"<p>Input-DTOs k\u00f6nnen mit <code>@Valid</code>, <code>@NotBlank</code>, <code>@Size</code> etc. annotiert werden, ohne die Entity zu verschmutzen. Die Entity bleibt fokussiert auf die Datenbank-Logik, das DTO auf die API-Validierung.</p>"},{"location":"06_DTOs_und_Mapping/#6-performance","title":"6. Performance","text":"<p>Entities enthalten oft gro\u00dfe Objektgraphen (z.B. ein Supplier mit 1000 Artikeln). DTOs serialisieren nur die wirklich ben\u00f6tigten Felder, was Bandbreite spart und die Antwortzeit reduziert.</p>"},{"location":"06_DTOs_und_Mapping/#7-saubere-architektur","title":"7. Saubere Architektur","text":"<p>DTOs geh\u00f6ren zur Pr\u00e4sentationsschicht, Entities zur Persistenzschicht. Diese Trennung folgt dem Separation of Concerns-Prinzip und macht die Anwendung wartbarer.</p>"},{"location":"06_DTOs_und_Mapping/#suppliercontroller-dtosicht","title":"Supplier\u2011Controller \u2013 DTO\u2011Sicht","text":"<p>Die Webschnittstelle soll vollst\u00e4ndige CRUD\u2011Funktionalit\u00e4t anbieten. Aus Client\u2011Sicht ergibt eine separate Trennung in <code>Supplier</code> und <code>Contact</code> wenig Sinn \u2013 wir nehmen/senden die Daten unnormalisiert (Name + Kontaktdaten in einem DTO).</p>"},{"location":"06_DTOs_und_Mapping/#mapping-strategie-statische-methoden-in-dtos","title":"Mapping-Strategie: Statische Methoden in DTOs","text":"<p>Statt eines zentralen <code>MappingService</code> (der schnell zu einer un\u00fcbersichtlichen \"God-Class\" wird) verwenden wir statische Mapping-Methoden direkt in den DTOs. </p> <p>Vorteile: - \u2705 Bessere Koh\u00e4sion: Die Mapping-Logik ist dort, wo sie hingeh\u00f6rt \u2013 im DTO selbst - \u2705 Keine God-Class: Jede DTO-Klasse bleibt klein und fokussiert - \u2705 Einfacher zu finden: Mapping-Logik ist direkt in der DTO-Klasse - \u2705 Weniger Abh\u00e4ngigkeiten: Kein zus\u00e4tzlicher Service n\u00f6tig</p> <p>Naming-Konvention: - <code>toEntity(dto)</code> \u2013 Konvertiert DTO zu Entity (bei Input-DTOs) - <code>toDto(entity)</code> \u2013 Konvertiert Entity zu DTO (bei Output-DTOs)</p>"},{"location":"06_DTOs_und_Mapping/#beispieldtos-mit-mapping-logik","title":"Beispiel\u2011DTOs mit Mapping-Logik","text":"<pre><code>@Getter\n@Setter\n@NoArgsConstructor\npublic class AddSupplierDto {\n    @NotBlank(message = \"Name is mandatory\")\n    private String name;\n\n    @NotBlank(message = \"Street is mandatory\")\n    private String street;\n\n    @NotBlank(message = \"Postcode is mandatory\")\n    private String postcode;\n\n    @NotBlank(message = \"City is mandatory\")\n    private String city;\n\n    @NotBlank(message = \"Phone is mandatory\")\n    private String phone;\n\n    /**\n     * Konvertiert dieses DTO in eine SupplierEntity mit ContactEntity\n     */\n    public static SupplierEntity toEntity(AddSupplierDto dto) {\n        SupplierEntity supplier = new SupplierEntity();\n        supplier.setName(dto.getName());\n\n        ContactEntity contact = new ContactEntity();\n        contact.setStreet(dto.getStreet());\n        contact.setPostcode(dto.getPostcode());\n        contact.setCity(dto.getCity());\n        contact.setPhone(dto.getPhone());\n\n        supplier.setContact(contact);\n        return supplier;\n    }\n}\n</code></pre>"},{"location":"07_SupplierController/","title":"SupplierController \u2013 Architektur &amp; Endpunkte","text":""},{"location":"07_SupplierController/#schichtenarchitektur-controller-vs-service","title":"Schichtenarchitektur: Controller vs. Service","text":"<p>In einer gut strukturierten Spring-Boot-Anwendung trennen wir die Verantwortlichkeiten klar in verschiedene Schichten:</p>"},{"location":"07_SupplierController/#was-macht-ein-controller","title":"Was macht ein Controller?","text":"<p>Der Controller ist Teil der Pr\u00e4sentationsschicht und hat folgende Aufgaben:</p> <ol> <li>HTTP-Kommunikation verwalten</li> <li>Endpunkte definieren (<code>@GetMapping</code>, <code>@PostMapping</code>, etc.)</li> <li>HTTP-Requests entgegennehmen</li> <li>HTTP-Status-Codes und Header setzen</li> <li> <p>HTTP-Responses zur\u00fcckgeben</p> </li> <li> <p>DTO-Handling</p> </li> <li>DTOs von JSON deserializieren (automatisch durch Spring)</li> <li>Eingabe-Validierung mit <code>@Valid</code> triggern</li> <li>DTOs zu Entities mappen (vor Service-Aufruf)</li> <li>Entities zu DTOs mappen (nach Service-Aufruf)</li> <li> <p>DTOs zu JSON serialisieren (automatisch durch Spring)</p> </li> <li> <p>Orchestrierung</p> </li> <li>Service-Methoden aufrufen</li> <li>Mehrere Service-Aufrufe koordinieren (falls n\u00f6tig)</li> <li>Exceptions in HTTP-Fehler \u00fcbersetzen</li> </ol> <p>Was macht ein Controller NICHT? - \u274c Business-Logik implementieren - \u274c Direkt mit Repositories arbeiten - \u274c Transaktionen verwalten - \u274c Komplexe Validierungen durchf\u00fchren</p>"},{"location":"07_SupplierController/#was-macht-ein-service","title":"Was macht ein Service?","text":"<p>Der Service ist Teil der Business-Logik-Schicht und hat folgende Aufgaben:</p> <ol> <li>Business-Logik implementieren</li> <li>Gesch\u00e4ftsregeln umsetzen (z.B. \"Ein Supplier muss mindestens einen Artikel haben\")</li> <li>Fachliche Validierungen (z.B. \"Dieser Name ist bereits vergeben\")</li> <li> <p>Berechnungen durchf\u00fchren</p> </li> <li> <p>Daten orchestrieren</p> </li> <li>Mit Repositories interagieren</li> <li>Mehrere Repository-Aufrufe koordinieren</li> <li> <p>Transaktionen verwalten (<code>@Transactional</code>)</p> </li> <li> <p>Domain-Objekte verarbeiten</p> </li> <li>Nur mit Entities arbeiten (keine DTOs!)</li> <li>Entity-Zust\u00e4nde verwalten</li> <li>Beziehungen zwischen Entities pflegen</li> </ol>"},{"location":"07_SupplierController/#warum-diese-trennung","title":"Warum diese Trennung?","text":"Vorteil Erkl\u00e4rung Wiederverwendbarkeit Der Service kann von verschiedenen Controllern genutzt werden (REST-API, GraphQL, gRPC) Testbarkeit Service-Tests sind einfacher (keine HTTP-Mocks n\u00f6tig) Separation of Concerns Jede Schicht hat eine klare Verantwortung Wartbarkeit \u00c4nderungen an der API betreffen nicht die Business-Logik Unabh\u00e4ngigkeit Business-Logik ist unabh\u00e4ngig von der Pr\u00e4sentationsform"},{"location":"07_SupplierController/#beispiel-flow","title":"Beispiel-Flow:","text":"<pre><code>1. Client sendet POST /api/suppliers mit JSON\n                \u2193\n2. Controller empf\u00e4ngt AddSupplierDto\n                \u2193\n3. Controller validiert DTO (@Valid)\n                \u2193\n4. Controller mappt DTO \u2192 SupplierEntity\n                \u2193\n5. Controller ruft service.createSupplier(entity) auf\n                \u2193\n6. Service f\u00fchrt Business-Validierung durch\n                \u2193\n7. Service speichert via repository.save(entity)\n                \u2193\n8. Service gibt gespeicherte Entity zur\u00fcck\n                \u2193\n9. Controller mappt Entity \u2192 GetSupplierDto\n                \u2193\n10. Controller gibt HTTP 201 + JSON zur\u00fcck\n</code></pre>"},{"location":"07_SupplierController/#supplierservice-implementieren","title":"SupplierService implementieren","text":"<p>Um das Single Responsibility Principle einzuhalten, lagern wir die Business-Logik in einen Service aus. Der Service arbeitet ausschlie\u00dflich mit Entities, nicht mit DTOs. </p> <p>Im Package <code>supplier</code> eine Klasse <code>SupplierService</code> anlegen (<code>@Service</code>) und das <code>SupplierRepository</code> via Konstruktor\u2011Injection einbinden (statt <code>@Autowired</code> \u2013 besser testbar und moderne Best Practice).</p> <pre><code>@Service\npublic class SupplierService {\n\n    private final SupplierRepository supplierRepository;\n\n    // Konstruktor-Injection (empfohlen)\n    public SupplierService(SupplierRepository supplierRepository) {\n      ...\n    }\n\n    // Service arbeitet NUR mit Entities\n    public SupplierEntity createSupplier(SupplierEntity supplier) {\n        // Hier k\u00f6nnte Business-Logik stehen, z.B.:\n        // - Pr\u00fcfen, ob Name bereits existiert\n        // - Standard-Werte setzen\n        // - Audit-Felder bef\u00fcllen\n        // - im Repository speichern\n        ...\n    }\n\n    public SupplierEntity findById(Long id) {\n        ...\n    }\n\n    public List&lt;SupplierEntity&gt; findAll() {\n      ...\n    }\n\n    public SupplierEntity updateSupplier(Long id, SupplierEntity updatedData) {\n        ...\n    }\n\n    public void deleteSupplier(Long id) {\n        ....\n    }\n}\n</code></pre> <p>Wichtig: Der Service ist f\u00fcr Repository\u2011Zugriffe und Business-Logik verantwortlich. Er arbeitet ausschlie\u00dflich mit Entities, kennt keine DTOs und ist damit unabh\u00e4ngig von der Pr\u00e4sentationsschicht. Sp\u00e4ter \u00fcbernimmt er auch komplexere Validierungen und wirft passende Exceptions.</p>"},{"location":"07_SupplierController/#controller-implementierung","title":"Controller-Implementierung","text":""},{"location":"07_SupplierController/#dtovalidierung-im-controller","title":"DTO\u2011Validierung im Controller","text":"<p>Neu ist die Annotation <code>@Valid</code> an Parameter\u2011DTOs im Controller (z. B. <code>AddSupplierDto</code>). Spring Boot validiert damit automatisch anhand der Bean\u2011Validation\u2011Annotationen im DTO (<code>@NotBlank</code>, <code>@Size</code>, etc.). Bei Validierungsfehlern wirft Spring automatisch eine <code>MethodArgumentNotValidException</code>.</p>"},{"location":"07_SupplierController/#beispiel-controller-mit-klarer-aufgabentrennung","title":"Beispiel-Controller mit klarer Aufgabentrennung","text":"<pre><code>@RestController\n@RequestMapping(\"/store/suppliers\")\npublic class SupplierController {\n\n\n    @PostMapping\n    // Response-Status 201 bei erfolgreichem Anlegen\n    @ResponseStatus(code = org.springframework.http.HttpStatus.CREATED)\n    public GetSupplierSimpleDTO create(@Valid @RequestBody final AddSupplierDTO dto) {\n        // 1. DTO \u2192 Entity\n        var addDtoEntity = AddSupplierDTO.toEntity(dto);\n        // 2. Service aufrufen (Business-Logik)\n        var savedEntity = this.supplierService.save(addDtoEntity);\n        // 3. Entity \u2192 DTO\n        return GetSupplierSimpleDTO.toDTO(savedEntity);\n    }\n\n    @GetMapping(\"{id}\")\n    public GetSupplierSimpleDTO get(@PathVariable Long id) {\n        var entity = this.supplierService.readById(id);\n        return GetSupplierSimpleDTO.toDTO(entity);\n    }\n\n    @GetMapping\n    public List&lt;GetSupplierSimpleDTO&gt; getAll() {\n        var entities =  this.supplierService.findAll();\n        return entities.stream().map(GetSupplierSimpleDTO::toDTO).toList();\n    }\n\n\n    @PutMapping(\"/{id}\")\n    ...\n\n    @DeleteMapping(\"/{id}\")\n    ...\n}\n</code></pre> <p>Beachte: Der Controller ist \"d\u00fcnn\" \u2013 er orchestriert nur, mappt DTOs und baut HTTP-Responses. Die gesamte Business-Logik steckt im Service.</p> <p>Der Code enth\u00e4lt einige \u00c4nderungen bez\u00fcglich der letzten Tutorials. Neu ist die Annotation <code>@Valid</code> des Parameters <code>addSupplierDto</code> in der Post-Methode. Sie bewirkt, dass Spring Boot das \u00fcbergebene Objekt hinsichtlich der Annotationen in der DTO-Klasse validiert. Da dessen Daten nicht mehr ge\u00e4ndert werden, wurde es mit dem Schl\u00fcsselwort final gekennzeichnet. Das validierte DTO wird in ein Business-Objekt vom Typ SupplierEntity umgewandelt. Es referenziert im Attribut contact seine Kontaktdaten. Im n\u00e4chsten Schritt wird der Supplier-Service damit beauftragt, das Objekt zu speichern. Beachte dabei, dass \u00fcber den CascadeType <code>ALL</code> in der Modellklasse <code>Supplier</code> das Contact-Object automatisch in der Datenbank gespeichert wird, ohne ein Contact-Repository benutzen zu m\u00fcssen. Der Supplier-Service gibt das gespeicherte Objekt zur\u00fcck, das der Controller wieder in ein DTO-Objekt verwandelt und dem Client im JSON-Format zur\u00fcckgibt. </p>"},{"location":"07_SupplierController/#aufgabe","title":"Aufgabe","text":"<p>Implementiere die Endpunkte zum Anlegen, Lesen (alle/ID), Aktualisieren, L\u00f6schen eines Lieferanten sowie einen Endpunkt \u201ealle Artikel eines Lieferanten\u201c.</p> <p>Teste die Endpunkte mit dem HTTP-Client von IntelliJ:</p> <pre><code>### Lieferant anlegen\nPOST localhost:8080/suppliers\nContent-Type: application/json\n\n{\n  \"name\": \"Kerstin's Supplies\",\n  \"city\": \"Bremen\",\n  \"postcode\": \"22345\",\n  \"street\": \"Bahnhofsstrasse 1\",\n  \"phone\": \"01209380192\"\n}\n\n### Alle Lieferanten lesen\nGET localhost:8080/suppliers\n\n### ....\n</code></pre>"},{"location":"08_Integrationstests/","title":"Integrationstests mit Testcontainers","text":"<p>Anstatt den Webservice immer h\u00e4ndisch \u00fcber Requests zu testen, nutzen wir automatisierte Integrationstests.</p>"},{"location":"08_Integrationstests/#was-ist-testcontainers","title":"Was ist Testcontainers?","text":"<p>Testcontainers ist eine Java-Bibliothek, die es erm\u00f6glicht, Docker-Container programmatisch f\u00fcr Tests zu starten und zu verwalten. </p>"},{"location":"08_Integrationstests/#vorteile-von-testcontainers","title":"Vorteile von Testcontainers:","text":"<ul> <li>Realistische Testumgebung: Statt Mock-Datenbanken oder In-Memory-Datenbanken (wie H2) wird eine echte PostgreSQL-Datenbank in einem Docker-Container gestartet. Dadurch testen wir mit der gleichen Datenbank, die auch in Produktion l\u00e4uft.</li> <li>Isolation: Jeder Test l\u00e4uft gegen eine saubere, isolierte Datenbankinstanz. Es gibt keine Konflikte zwischen verschiedenen Testl\u00e4ufen.</li> <li>Automatisierung: Der Container wird automatisch gestartet, wenn die Tests beginnen, und wieder heruntergefahren, wenn sie beendet sind.</li> <li>CI/CD-freundlich: Solange Docker auf der Test-Maschine (z.B. GitHub Actions, Jenkins) verf\u00fcgbar ist, funktionieren die Tests ohne zus\u00e4tzliche Konfiguration.</li> </ul> <p>In unserem Fall nutzen wir Testcontainers, um f\u00fcr jeden Testlauf einen PostgreSQL-Container zu starten, der die gleiche Datenbank-Engine verwendet wie in der Produktion.</p>"},{"location":"08_Integrationstests/#abhangigkeiten-buildgradlekts","title":"Abh\u00e4ngigkeiten <code>build.gradle.kts</code>","text":"<pre><code>testImplementation(\"org.testcontainers:testcontainers\")\ntestImplementation(\"org.testcontainers:postgresql\")\n</code></pre>"},{"location":"08_Integrationstests/#abstractintegrationtest","title":"AbstractIntegrationTest","text":"<p>Erzeuge im Ordner <code>test/java/de/szut/store</code> das Package <code>testcontainers</code> und lege folgende Klassen an.</p> <p><pre><code>@SpringBootTest\n@AutoConfigureMockMvc\n@ActiveProfiles(\"it\")\n@ContextConfiguration(initializers = PostgresContextInitializer.class)\npublic class AbstractIntegrationTest {\n\n    @Autowired\n    protected MockMvc mockMvc;\n\n    @Autowired\n    protected ArticleRepository articleRepository;\n\n    @Autowired\n    protected SupplierRepository supplierRepository;\n\n    @BeforeEach\n    void setUp() {\n        articleRepository.deleteAll();\n        supplierRepository.deleteAll();\n    }\n}\n</code></pre> Dem Test wird per Dependency-Injection eine Instanz vom Typ <code>MockMvc</code> zur Verf\u00fcgung gestellt. Mit dem Tool <code>MockMvc</code> stellt Spring eine sehr gute M\u00f6glichkeit bereit Spring Boot Applikationen zu testen. Es startet einen kompletten Mock des Spring -Web-MVC-Moduls, sprich: Es bildet URLs auf Controller ab, l\u00e4dt Exception Handler und mehr. Die <code>setUp</code>-Methode wird dank der Annotation <code>@BeforeEach</code> vor jedem Test ausgef\u00fchrt und bewirkt in diesem Fall, dass die Datenbank geleert wird.</p>"},{"location":"08_Integrationstests/#test-profileigenschaften","title":"Test-Profileigenschaften","text":"<p>Lege <code>application-it.properties</code> an:</p> <pre><code>spring.datasource.url=set_by_test_containers\nspring.datasource.username=set_by_test_containers\nspring.datasource.password=set_by_test_containers\n</code></pre>"},{"location":"08_Integrationstests/#postgrescontextinitializer","title":"PostgresContextInitializer","text":"<pre><code>public class PostgresContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {\n    private static final PostgreSQLContainer&lt;?&gt; postgres = new PostgreSQLContainer&lt;&gt;(DockerImageName.parse(\"postgres:14\"))\n            .withDatabaseName(\"test_db\")\n            .withUsername(\"test-db-user\")\n            .withPassword(\"test-db-password\")\n            .withReuse(true);\n\n    @Override\n    public void initialize(ConfigurableApplicationContext context) {\n        postgres.start();\n        TestPropertyValues.of(\n                \"spring.datasource.url=\" + postgres.getJdbcUrl(),\n                \"spring.datasource.username=\" + postgres.getUsername(),\n                \"spring.datasource.password=\" + postgres.getPassword()\n        ).applyTo(context.getEnvironment());\n    }\n}\n</code></pre>"},{"location":"08_Integrationstests/#beispieltests","title":"Beispieltests","text":""},{"location":"08_Integrationstests/#postsupplierit","title":"PostSupplierIT","text":"<pre><code>public class PostSupplierIT extends AbstractIntegrationTest {\n    @Test\n    @Transactional\n    void postSupplier() throws Exception {\n        String content = \"{\\n\" +\n                \"  \\\"name\\\": \\\"Meier\\\",\\n\" +\n                \"  \\\"street\\\": \\\"Benquestra\u00dfe 50\\\",\\n\" +\n                \"  \\\"postcode\\\": \\\"28209\\\",\\n\" +\n                \"  \\\"city\\\": \\\"Bremen\\\",\\n\" +\n                \"  \\\"phone\\\": \\\"01637122020\\\"\\n\" +\n                \"}\";\n\n        final var contentAsString = this.mockMvc.perform(post(\"/store/supplier\").content(content).contentType(MediaType.APPLICATION_JSON))\n                .andExpect(status().isCreated())\n                .andExpect(jsonPath(\"name\", is(\"Meier\")))\n                .andExpect(jsonPath(\"street\", is(\"Benquestra\u00dfe 50\")))\n                .andExpect(jsonPath(\"city\", is(\"Bremen\")))\n                .andExpect(jsonPath(\"postcode\", is(\"28209\")))\n                .andExpect(jsonPath(\"phone\", is(\"01637122020\")))\n                .andReturn()\n                .getResponse()\n                .getContentAsString();\n\n        final var id = Long.parseLong(new JSONObject(contentAsString).get(\"sid\").toString());\n\n        final var loadedEntity = supplierRepository.findById(id);\n        assertThat(loadedEntity.get().getName()).isEqualTo(\"Meier\");\n        assertThat(loadedEntity.get().getContact().getStreet()).isEqualTo(\"Benquestra\u00dfe 50\");\n        assertThat(loadedEntity.get().getContact().getPostcode()).isEqualTo(\"28209\");\n        assertThat(loadedEntity.get().getContact().getCity()).isEqualTo(\"Bremen\");\n        assertThat(loadedEntity.get().getContact().getPhone()).isEqualTo(\"01637122020\");\n    }\n}\n</code></pre>"},{"location":"08_Integrationstests/#erklarung-des-tests","title":"Erkl\u00e4rung des Tests","text":"<p>Struktur: - Die Test-Klasse erweitert <code>AbstractIntegrationTest</code> und erbt damit die Test-Infrastruktur (MockMvc, Repositories, setUp-Methode) - Die Test-Methode ist mit <code>@Test</code> annotiert, damit JUnit sie als Test erkennt</p> <p>Test-Ablauf in zwei Phasen:</p>"},{"location":"08_Integrationstests/#phase-1-http-request-testen","title":"Phase 1: HTTP-Request testen","text":"<p>Erzeuge den JSON-Request-Body als String: <pre><code>String content = \"{\\n\" +\n                \"  \\\"name\\\": \\\"Meier\\\",\\n\" +\n                ...\n                \"}\";\n````\nDer JSON-String enth\u00e4lt die Daten f\u00fcr den neuen Lieferanten. Die Struktur der JSON-Daten muss dem `AddSupplierDTO` entsprechen!\n\n```java\nthis.mockMvc.perform(post(\"/store/supplier\")\n        .content(content)\n        .contentType(MediaType.APPLICATION_JSON))\n    .andExpect(status().isCreated())\n    .andExpect(jsonPath(\"name\", is(\"Meier\")))\n    // ... weitere Assertions\n</code></pre></p> <p>Mit <code>mockMvc.perform()</code> wird ein simulierter HTTP-Request an den Controller gesendet. Anschlie\u00dfend k\u00f6nnen wir die komplette Response pr\u00fcfen: - Status-Code: <code>status().isCreated()</code> erwartet HTTP 201 - Response-Body: <code>jsonPath()</code> pr\u00fcft einzelne JSON-Felder mit JSONPath-Syntax - Header: K\u00f6nnte mit <code>andExpect(header().exists(\"Location\"))</code> gepr\u00fcft werden</p>"},{"location":"08_Integrationstests/#phase-2-datenbank-persistierung-verifizieren","title":"Phase 2: Datenbank-Persistierung verifizieren","text":"<pre><code>final var id = Long.parseLong(new JSONObject(contentAsString).get(\"sid\").toString());\nfinal var loadedEntity = supplierRepository.findById(id);\nassertThat(loadedEntity.get().getName()).isEqualTo(\"Meier\");\n</code></pre> <p>Nachdem wir die HTTP-Response gepr\u00fcft haben: 1. ID extrahieren: Aus der JSON-Response wird die generierte <code>sid</code> ausgelesen 2. Entity laden: Mit dieser ID wird direkt aus der Datenbank gelesen 3. Persistierung pr\u00fcfen: Mit AssertJ (<code>assertThat</code>) wird verifiziert, dass die Daten korrekt gespeichert wurden</p> <p>Warum beide Phasen? Ein vollst\u00e4ndiger Integrationstest pr\u00fcft nicht nur die HTTP-Schnittstelle, sondern auch die tats\u00e4chliche Datenpersistierung. So stellen wir sicher, dass der gesamte Stack (Controller \u2192 Service \u2192 Repository \u2192 Datenbank) funktioniert.</p> <p>Wichtig: <code>@Transactional</code> auf der Test-Methode Diese Annotation ist notwendig, weil <code>ContactEntity</code> im Supplier via Lazy-Loading (<code>FetchType.LAZY</code>) nachgeladen wird. Lazy-Loading funktioniert nur innerhalb einer aktiven Datenbanktransaktion. Ohne <code>@Transactional</code> w\u00fcrde beim Zugriff auf <code>loadedEntity.get().getContact()</code> eine <code>LazyInitializationException</code> geworfen.</p>"},{"location":"08_Integrationstests/#test-ausfuhren","title":"Test ausf\u00fchren","text":"<p>Voraussetzung: Docker-Daemon muss laufen (Testcontainers ben\u00f6tigt Docker zum Starten des PostgreSQL-Containers).</p> <p>F\u00fchre den Test aus \u00fcber: - IntelliJ: Rechtsklick auf Test-Klasse \u2192 \"Run\" - Terminal: <code>./gradlew test</code> oder <code>./gradlew test --tests PostSupplierIT</code></p> <p>Beim ersten Durchlauf l\u00e4dt Testcontainers das PostgreSQL-Image herunter (kann einige Minuten dauern). </p>"},{"location":"08_Integrationstests/#supplierfindallit","title":"SupplierFindAllIT","text":"<p>Hier ein weiterer Beispieltest f\u00fcr den Endpunkt \u201ealle Lieferanten holen\u201c:</p> <pre><code>public class SupplierFindAllIT extends AbstractIntegrationTest {\n    @Test\n    void findAll() throws Exception {\n        var supplier1 = new SupplierEntity();\n        supplier1.setName(\"Meier\");\n        var contact1 = new ContactEntity();\n        contact1.setStreet(\"Hauptstra\u00dfe\");\n        contact1.setPostcode(\"12345\");\n        contact1.setCity(\"Bremen\");\n        contact1.setPhone(\"+4912345\");\n        supplier1.setContact(contact1);\n        this.supplierRepository.save(supplier1);\n\n        this.mockMvc.perform(get(\"/store/supplier\"))\n                .andExpect(status().is2xxSuccessful())\n                .andExpect(jsonPath(\"$\", hasSize(1)))\n                .andExpect(jsonPath(\"$[0].name\", is(\"Meier\")))\n                .andExpect(jsonPath(\"$[0].street\", is(\"Hauptstra\u00dfe\")))\n                .andExpect(jsonPath(\"$[0].postcode\", is(\"12345\")))\n                .andExpect(jsonPath(\"$[0].city\", is(\"Bremen\")))\n                .andExpect(jsonPath(\"$[0].phone\", is(\"+4912345\")));\n    }\n}\n</code></pre>"},{"location":"08_Integrationstests/#aufgabe","title":"Aufgabe","text":"<p>Erg\u00e4nze einen Integrationstest f\u00fcr \u201eget by id\u201c.</p>"},{"location":"09_ExceptionHandling/","title":"Zentrales Exception-Handling","text":""},{"location":"09_ExceptionHandling/#warum-brauchen-wir-exception-handling","title":"Warum brauchen wir Exception-Handling?","text":""},{"location":"09_ExceptionHandling/#das-problem-spring-boots-standard-fehlerantworten","title":"Das Problem: Spring Boots Standard-Fehlerantworten","text":"<p>Beim Ausf\u00fchren eines fehlerhaften Requests (z.B. POST mit ung\u00fcltigen Daten oder GET mit nicht existierender ID) liefert Spring Boot standardm\u00e4\u00dfig eine sehr generische Fehlerantwort wie diese:</p> <pre><code>{\n  \"timestamp\": \"2025-10-08T11:58:08.139+00:00\",\n  \"status\": 500,\n  \"error\": \"Internal Server Error\",\n  \"path\": \"/store/supplier\"\n}\n</code></pre> <p>Oder bei Validierungsfehlern manchmal auch:</p> <pre><code>{\n  \"timestamp\": \"2025-10-08T11:58:08.139+00:00\",\n  \"status\": 400,\n  \"error\": \"Bad Request\",\n  \"path\": \"/store/supplier\"\n}\n</code></pre> <p>Probleme dieser Standard-Antworten:</p> <ol> <li>\u274c Keine konkrete Fehlermeldung: Was genau ist schiefgelaufen? Welches Feld fehlt?</li> <li>\u274c Kein <code>message</code>-Feld: Clients m\u00fcssen aus <code>status</code> und <code>error</code> selbst interpretieren</li> <li>\u274c Nicht aussagekr\u00e4ftig: \"Internal Server Error\" sagt nichts \u00fcber die Ursache</li> <li>\u274c Nicht einheitlich: Je nach Exception-Typ unterschiedliche Strukturen (manchmal mit <code>message</code>, manchmal ohne)</li> <li>\u274c Client-unfreundlich: Keine programmatisch auswertbaren Details</li> <li>\u274c Falsche Status-Codes: Oft 500 statt 404 bei \"nicht gefunden\"</li> </ol>"},{"location":"09_ExceptionHandling/#die-losung-zentrales-exception-handling","title":"Die L\u00f6sung: Zentrales Exception-Handling","text":"<p>Wir implementieren ein einheitliches, aussagekr\u00e4ftiges Fehlerhandling f\u00fcr alle Controller:</p> <p>Vorteile: - \u2705 Einheitliche Fehlerstruktur f\u00fcr alle Endpunkte - \u2705 Aussagekr\u00e4ftige, benutzerfreundliche Fehlermeldungen - \u2705 Korrekte HTTP-Statuscodes (404, 400, 500, etc.) - \u2705 Keine Code-Duplizierung in jedem Controller - \u2705 Zentrale Verwaltung aller Exceptions - \u2705 Maschinell verarbeitbare Fehlerantworten</p>"},{"location":"09_ExceptionHandling/#schritt-1-eigene-exception-fur-nicht-gefunden","title":"Schritt 1: Eigene Exception f\u00fcr \"Nicht gefunden\"","text":""},{"location":"09_ExceptionHandling/#aufgabe","title":"Aufgabe","text":"<p>Erstelle im Package <code>exceptionhandling</code> die Klasse <code>ResourceNotFoundException</code>:</p> <pre><code>package de.szut.store.exceptionhandling;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.web.bind.annotation.ResponseStatus;\n\n@ResponseStatus(HttpStatus.NOT_FOUND)\npublic class ResourceNotFoundException extends RuntimeException {\n\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n}\n</code></pre>"},{"location":"09_ExceptionHandling/#erklarung","title":"Erkl\u00e4rung","text":"<p>Warum von <code>RuntimeException</code> erben? - RuntimeExceptions sind unchecked \u2013 Methoden m\u00fcssen nicht mit <code>throws</code> deklariert werden - Der Code bleibt sauber ohne \u00fcberall Exception-Deklarationen</p> <p>Was macht <code>@ResponseStatus(HttpStatus.NOT_FOUND)</code>? - Legt automatisch den HTTP-Statuscode 404 (Not Found) fest - Sobald diese Exception geworfen wird, antwortet Spring mit Status 404 - Ohne diese Annotation w\u00fcrde standardm\u00e4\u00dfig 500 (Internal Server Error) zur\u00fcckgegeben</p>"},{"location":"09_ExceptionHandling/#schritt-2-einheitliche-fehlerstruktur-definieren","title":"Schritt 2: Einheitliche Fehlerstruktur definieren","text":""},{"location":"09_ExceptionHandling/#aufgabe_1","title":"Aufgabe","text":"<p>Erstelle im Package <code>exceptionhandling</code> die Klasse <code>ErrorDetails</code>:</p> <pre><code>package de.szut.store.exceptionhandling;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport java.time.LocalDateTime;\n\n@Data\n@AllArgsConstructor\npublic class ErrorDetails {\n    private LocalDateTime timestamp;  // Zeitpunkt des Fehlers\n    private String message;            // Benutzerfreundliche Fehlermeldung\n    private String details;            // Zusatzinfos (z.B. URI-Pfad)\n}\n</code></pre>"},{"location":"09_ExceptionHandling/#erklarung_1","title":"Erkl\u00e4rung","text":"<p>Diese Klasse definiert die einheitliche Struktur f\u00fcr alle Fehlerantworten:</p> <ul> <li><code>timestamp</code>: Wann ist der Fehler aufgetreten? (wichtig f\u00fcr Logging/Debugging)</li> <li><code>message</code>: Die Haupt-Fehlermeldung f\u00fcr den Client (z.B. \"Supplier not found on Id = 3\")</li> <li><code>details</code>: Zus\u00e4tzliche Kontext-Informationen (z.B. welcher Endpunkt aufgerufen wurde)</li> </ul> <p><code>@AllArgsConstructor</code> generiert einen Konstruktor mit allen drei Parametern, damit wir einfach Instanzen erstellen k\u00f6nnen.</p>"},{"location":"09_ExceptionHandling/#schritt-3-zentraler-exception-handler","title":"Schritt 3: Zentraler Exception-Handler","text":""},{"location":"09_ExceptionHandling/#aufgabe_2","title":"Aufgabe","text":"<p>Erstelle im Package <code>exceptionhandling</code> die Klasse <code>GlobalExceptionHandler</code>:</p> <pre><code>package de.szut.store.exceptionhandling;\n\nimport jakarta.validation.ConstraintViolationException;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.context.request.WebRequest;\n\nimport java.time.LocalDateTime;\n\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    /**\n     * Behandelt ResourceNotFoundException (404 - Not Found)\n     * Wird geworfen, wenn eine angeforderte Ressource nicht existiert\n     */\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity&lt;ErrorDetails&gt; handleResourceNotFound(\n            ResourceNotFoundException ex, \n            WebRequest request) {\n\n        ErrorDetails error = new ErrorDetails(\n            LocalDateTime.now(),\n            ex.getMessage(),\n            request.getDescription(false)\n        );\n        return new ResponseEntity&lt;&gt;(error, HttpStatus.NOT_FOUND);\n    }\n\n    /**\n     * Behandelt MethodArgumentNotValidException (400 - Bad Request)\n     * Wird von @Valid automatisch geworfen, wenn DTO-Validierung fehlschl\u00e4gt\n     */\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity&lt;ErrorDetails&gt; handleValidation(\n            MethodArgumentNotValidException ex, \n            WebRequest request) {\n\n        // Extrahiere die erste Fehlermeldung aus den Validierungs-Errors\n        String message = ex.getBindingResult()\n            .getFieldErrors()\n            .get(0)\n            .getDefaultMessage();\n\n        ErrorDetails error = new ErrorDetails(\n            LocalDateTime.now(),\n            message,\n            request.getDescription(false)\n        );\n        return new ResponseEntity&lt;&gt;(error, HttpStatus.BAD_REQUEST);\n    }\n\n    /**\n     * Behandelt ConstraintViolationException (400 - Bad Request)\n     * Wird geworfen, wenn Bean-Validation-Constraints verletzt werden\n     */\n    @ExceptionHandler(ConstraintViolationException.class)\n    public ResponseEntity&lt;ErrorDetails&gt; handleConstraintViolation(\n            ConstraintViolationException ex, \n            WebRequest request) {\n\n        // Extrahiere die erste Constraint-Verletzungs-Nachricht\n        String message = ex.getConstraintViolations()\n            .iterator()\n            .next()\n            .getMessage();\n\n        ErrorDetails error = new ErrorDetails(\n            LocalDateTime.now(),\n            message,\n            request.getDescription(false)\n        );\n        return new ResponseEntity&lt;&gt;(error, HttpStatus.BAD_REQUEST);\n    }\n\n    /**\n     * Behandelt alle anderen Exceptions (500 - Internal Server Error)\n     * Fallback f\u00fcr unerwartete Fehler\n     */\n    @ExceptionHandler(Exception.class)\n    public ResponseEntity&lt;ErrorDetails&gt; handleGlobalException(\n            Exception ex, \n            WebRequest request) {\n\n        ErrorDetails error = new ErrorDetails(\n            LocalDateTime.now(),\n            \"Internal server error\",\n            request.getDescription(false)\n        );\n        return new ResponseEntity&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}\n</code></pre>"},{"location":"09_ExceptionHandling/#erklarung-wie-funktioniert-das","title":"Erkl\u00e4rung: Wie funktioniert das?","text":""},{"location":"09_ExceptionHandling/#controlleradvice","title":"<code>@ControllerAdvice</code>","text":"<p>Diese Annotation macht die Klasse zu einem globalen Controller-Berater: - Gilt f\u00fcr alle Controller in der Anwendung - Zentrale Stelle f\u00fcr Exception-Handling - Spring wendet diese Handler automatisch auf alle Endpunkte an</p>"},{"location":"09_ExceptionHandling/#exceptionhandlerexceptiontypeclass","title":"<code>@ExceptionHandler(ExceptionType.class)</code>","text":"<p>Definiert, welche Exception-Methode behandelt: - Sobald irgendwo in der Anwendung diese Exception geworfen wird - Wird automatisch die annotierte Methode aufgerufen - Die Methode baut eine passende HTTP-Response</p>"},{"location":"09_ExceptionHandling/#handler-flow-am-beispiel-resourcenotfoundexception","title":"Handler-Flow am Beispiel <code>ResourceNotFoundException</code>:","text":"<pre><code>1. Service wirft: throw new ResourceNotFoundException(\"Supplier not found\")\n                            \u2193\n2. Spring f\u00e4ngt Exception ab\n                            \u2193\n3. Spring sucht passenden @ExceptionHandler\n                            \u2193\n4. handleResourceNotFound() wird ausgef\u00fchrt\n                            \u2193\n5. ErrorDetails-Objekt wird erstellt\n                            \u2193\n6. ResponseEntity mit Status 404 wird zur\u00fcckgegeben\n                            \u2193\n7. Spring serialisiert ErrorDetails zu JSON\n                            \u2193\n8. Client erh\u00e4lt einheitliche Fehlerantwort\n</code></pre>"},{"location":"09_ExceptionHandling/#schritt-4-exception-im-service-verwenden","title":"Schritt 4: Exception im Service verwenden","text":""},{"location":"09_ExceptionHandling/#aufgabe_3","title":"Aufgabe","text":"<p>Passe die Methode <code>findById()</code> im <code>SupplierService</code> an:</p> <pre><code>@Service\npublic class SupplierService {\n\n    private final SupplierRepository supplierRepository;\n\n    public SupplierService(SupplierRepository supplierRepository) {\n        this.supplierRepository = supplierRepository;\n    }\n\n    public SupplierEntity findById(Long id) {\n        return supplierRepository.findById(id)\n            .orElseThrow(() -&gt; new ResourceNotFoundException(\n                \"Supplier not found on Id = \" + id));\n    }\n\n    // ... weitere Methoden\n}\n</code></pre>"},{"location":"09_ExceptionHandling/#testen","title":"Testen","text":"<p>Test-Request: <pre><code>GET http://localhost:8080/store/supplier/999\n</code></pre></p> <p>Erwartete Antwort (Status 404): <pre><code>{\n  \"timestamp\": \"2025-10-08T14:23:11.770\",\n  \"message\": \"Supplier not found on Id = 999\",\n  \"details\": \"uri=/store/supplier/999\"\n}\n</code></pre></p> <p>\u2705 Viel besser! Klare Fehlermeldung, korrekte Statuscode, einheitliche Struktur.</p>"},{"location":"09_ExceptionHandling/#testen-die-verschiedenen-fehlertypen","title":"Testen: Die verschiedenen Fehlertypen","text":"<p>Jetzt k\u00f6nnen wir die verschiedenen Exception-Handler testen:</p>"},{"location":"09_ExceptionHandling/#test-1-resourcenotfoundexception-404-not-found","title":"Test 1: ResourceNotFoundException (404 Not Found)","text":"<p>Test-Request (nicht existierende ID): <pre><code>GET http://localhost:8080/store/supplier/999\n</code></pre></p> <p>Erwartete Antwort: <pre><code>{\n  \"timestamp\": \"2025-10-08T14:23:11.770\",\n  \"message\": \"Supplier not found on Id = 999\",\n  \"details\": \"uri=/store/supplier/999\"\n}\n</code></pre></p> <p>\u2705 Status 404, klare Fehlermeldung!</p>"},{"location":"09_ExceptionHandling/#test-2-methodargumentnotvalidexception-400-bad-request","title":"Test 2: MethodArgumentNotValidException (400 Bad Request)","text":"<p>Test-Request (fehlender Name): <pre><code>POST http://localhost:8080/store/supplier\nContent-Type: application/json\n\n{\n  \"street\": \"Hauptstra\u00dfe 1\",\n  \"postcode\": \"28209\",\n  \"city\": \"Bremen\",\n  \"phone\": \"0421123456\"\n}\n</code></pre></p> <p>Erwartete Antwort: <pre><code>{\n  \"timestamp\": \"2025-10-08T14:25:33.123\",\n  \"message\": \"Name is mandatory\",\n  \"details\": \"uri=/store/supplier\"\n}\n</code></pre></p> <p>\u2705 Nur die relevante Fehlermeldung aus der <code>@NotBlank(message = \"...\")</code>-Annotation!</p> <p>Wichtig: Die Handler f\u00fcr <code>MethodArgumentNotValidException</code> und <code>ConstraintViolationException</code> extrahieren automatisch die benutzerdefinierten Fehlermeldungen aus den Validierungs-Annotationen im DTO:</p> <pre><code>// Im AddSupplierDto:\n@NotBlank(message = \"Name is mandatory\")  // \u2190 Diese Message wird verwendet\nprivate String name;\n</code></pre>"},{"location":"09_ExceptionHandling/#test-3-constraintviolationexception-400-bad-request","title":"Test 3: ConstraintViolationException (400 Bad Request)","text":"<p>Test-Request (ung\u00fcltige Postleitzahl): <pre><code>POST http://localhost:8080/store/supplier\nContent-Type: application/json\n\n{\n  \"name\": \"Test Supplier\",\n  \"street\": \"Hauptstra\u00dfe 1\",\n  \"postcode\": \"123456789\",\n  \"city\": \"Bremen\",\n  \"phone\": \"0421123456\"\n}\n</code></pre></p> <p>Erwartete Antwort: <pre><code>{\n  \"timestamp\": \"2025-10-08T14:27:15.456\",\n  \"message\": \"Postcode must be 5 characters\",\n  \"details\": \"uri=/store/supplier\"\n}\n</code></pre></p> <p>\u2705 Auch hier wird die Message aus der <code>@Size</code>-Annotation verwendet!</p>"},{"location":"09_ExceptionHandling/#ubersicht-welcher-handler-fur-welchen-fehler","title":"\u00dcbersicht: Welcher Handler f\u00fcr welchen Fehler?","text":"Exception HTTP-Status Wann wird sie geworfen? Beispiel <code>ResourceNotFoundException</code> 404 Not Found Ressource existiert nicht Supplier mit ID 999 nicht gefunden <code>MethodArgumentNotValidException</code> 400 Bad Request <code>@Valid</code> schl\u00e4gt fehl Pflichtfeld fehlt in POST-Request <code>ConstraintViolationException</code> 400 Bad Request Bean-Validation verletzt Ung\u00fcltige Postleitzahl (zu lang) <code>Exception</code> (alle anderen) 500 Internal Server Error Unerwarteter Fehler Datenbankverbindung fehlgeschlagen"},{"location":"09_ExceptionHandling/#pro-contra-zentrales-exception-handling","title":"Pro &amp; Contra: Zentrales Exception-Handling","text":""},{"location":"09_ExceptionHandling/#vorteile","title":"\u2705 Vorteile","text":"Vorteil Erkl\u00e4rung Keine Duplizierung Code wird nur einmal geschrieben, gilt f\u00fcr alle Controller Einheitlichkeit Alle Fehler haben die gleiche Struktur Wartbarkeit \u00c4nderungen an Fehlerstruktur an einer Stelle \u00dcbersichtlichkeit Alle Exception-Typen zentral dokumentiert Separation of Concerns Controller bleiben fokussiert auf Business-Logik"},{"location":"09_ExceptionHandling/#nachteile","title":"\u26a0\ufe0f Nachteile","text":"Nachteil Erkl\u00e4rung Weniger Kontrolle Exceptions \"verschwinden\" aus dem Controller Debugging schwieriger Stack-Traces m\u00fcssen genau angeschaut werden \u00dcbersicht geht verloren Welche Exceptions kann ein Endpunkt werfen?"},{"location":"09_ExceptionHandling/#alternative-controller-basiertes-exception-handling","title":"Alternative: Controller-basiertes Exception-Handling","text":"<p>Manche Teams bevorzugen Exception-Handling pro Controller:</p> <pre><code>@RestController\n@RequestMapping(\"/store/supplier\")\npublic class SupplierController {\n\n    // ... Controller-Methoden\n\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity&lt;ErrorDetails&gt; handleNotFound(ResourceNotFoundException ex) {\n        // Nur f\u00fcr diesen Controller\n    }\n}\n</code></pre> <p>Vorteil: Entwickler sieht sofort, welche Exceptions der Controller werfen kann Nachteil: Code-Duplizierung in jedem Controller</p>"},{"location":"09_ExceptionHandling/#zusammenfassung","title":"Zusammenfassung","text":"<ol> <li>Eigene Exceptions definieren (<code>ResourceNotFoundException</code>) f\u00fcr fachliche Fehler</li> <li>Einheitliche Fehlerstruktur (<code>ErrorDetails</code>) f\u00fcr alle Responses</li> <li>Zentraler Handler (<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>) f\u00fcr alle Controller</li> <li>Aussagekr\u00e4ftige Messages aus Validierungs-Annotationen extrahieren</li> <li>Korrekte HTTP-Statuscodes f\u00fcr jeden Fehlertyp</li> </ol> <p>Ergebnis: Eine professionelle REST-API mit klaren, einheitlichen Fehlermeldungen! \ud83c\udf89 ```</p>"},{"location":"10_ArticleController/","title":"ArticleController \u2013 Endpunkte und Umsetzung","text":""},{"location":"10_ArticleController/#warum-separate-article-endpunkte","title":"Warum separate Article-Endpunkte?","text":"<p>Nachdem wir den <code>SupplierController</code> implementiert haben, k\u00fcmmern wir uns nun um die Artikel-Verwaltung. Artikel sind zwar mit Lieferanten verkn\u00fcpft, ben\u00f6tigen aber eigene Endpunkte, um:</p> <ul> <li>Alle Artikel unabh\u00e4ngig vom Lieferanten abzurufen</li> <li>Einzelne Artikel gezielt zu suchen (nach ID oder Bezeichnung)</li> <li>Neue Artikel einem bestimmten Lieferanten zuzuordnen</li> </ul>"},{"location":"10_ArticleController/#dto-design-weniger-ist-mehr","title":"DTO-Design: Weniger ist mehr","text":"<p>Bei den Attributen der <code>ArticleEntity</code> sind <code>lastUpdateDate</code> und <code>createDate</code> f\u00fcr API-Clients meist irrelevant:</p> <ul> <li>Diese Felder sind reine Metadaten f\u00fcr interne Zwecke (Auditing, Debugging)</li> <li>Sie erh\u00f6hen nur die Response-Gr\u00f6\u00dfe</li> <li>Clients interessiert meist nur: Was ist der Artikel, was kostet er, wer liefert ihn</li> </ul> <p>L\u00f6sung: \u00dcber DTOs geben wir nur die wirklich ben\u00f6tigten Felder heraus: <code>id</code>, <code>designation</code>, <code>price</code>.</p>"},{"location":"10_ArticleController/#endpunkte-vorgabe","title":"Endpunkte (Vorgabe)","text":"Art Pfad Ziel GET <code>/store/article</code> liefert alle Artikel jeweils mit den Daten <code>id</code>, <code>designation</code>, <code>price</code> GET <code>/store/article/{id}</code> liefert einen Artikel anhand seiner Id (<code>id</code>, <code>designation</code>, <code>price</code>) GET <code>/store/article{designation}</code> liefert einen Artikel anhand seiner Beschreibung (<code>id</code>, <code>designation</code>, <code>price</code>) POST <code>/store/article/{id}</code> legt einen neuen Artikel f\u00fcr den Lieferanten mit der gew\u00fcnschten Id an; \u00fcbergeben werden <code>designation</code> und <code>price</code> in einem DTO, zur\u00fcckgegeben werden <code>id</code>, <code>designation</code>, <code>price</code> <p>Implementiere die Endpunkte gem\u00e4\u00df der zuvor erl\u00e4uterten Architektur. Formuliere Requests/Integrationstests.</p>"},{"location":"11_Erweiterungen/","title":"Erweiterungen","text":""},{"location":"11_Erweiterungen/#1-weitere-article-endpunkte","title":"1. Weitere Article-Endpunkte","text":"<p>Lege im <code>ArticleController</code> weitere sinnvolle Endpunkte an:</p> <p>M\u00f6gliche Erweiterungen: - <code>PUT /store/article/{id}</code> \u2013 Artikel aktualisieren - <code>DELETE /store/article/{id}</code> \u2013 Artikel l\u00f6schen - <code>GET /store/article/supplier/{supplierId}</code> \u2013 Alle Artikel eines Suppliers - <code>PATCH /store/article/{id}</code> \u2013 Nur z.B. Preis aktualisieren</p>"},{"location":"11_Erweiterungen/#2-integrationstests","title":"2. Integrationstests","text":"<p>Versehe jeden Endpunkt mit einem Integrationstest. Stelle sicher, dass: - \u2705 Erfolgreiche Requests getestet werden (Happy Path) - \u2705 Fehlerszenarien getestet werden (z.B. nicht existierende IDs) - \u2705 Validierungen gepr\u00fcft werden (z.B. negative Preise) - \u2705 Datenbank-Persistierung verifiziert wird</p>"},{"location":"11_Erweiterungen/#3-hateoas-hypermedia-as-the-engine-of-application-state","title":"3. HATEOAS \u2013 Hypermedia as the Engine of Application State","text":""},{"location":"11_Erweiterungen/#was-ist-hateoas","title":"Was ist HATEOAS?","text":"<p>HATEOAS ist ein Prinzip von REST-APIs, bei dem die Response Links zu verwandten Ressourcen enth\u00e4lt. Der Client muss URLs nicht selbst zusammenbauen, sondern folgt den bereitgestellten Links.</p> <p>Kernidee: Eine REST-API sollte wie eine Website funktionieren \u2013 der Client entdeckt verf\u00fcgbare Aktionen durch Links in der Antwort.</p>"},{"location":"11_Erweiterungen/#vorteile-von-hateoas","title":"Vorteile von HATEOAS","text":"Vorteil Beschreibung Entkopplung Client muss URL-Struktur nicht kennen Self-Discovery API ist selbstbeschreibend Evolvability URLs k\u00f6nnen sich \u00e4ndern, ohne Clients zu brechen Bessere UX Client wei\u00df, welche Aktionen m\u00f6glich sind"},{"location":"11_Erweiterungen/#beispiel-ohne-vs-mit-hateoas","title":"Beispiel: Ohne vs. Mit HATEOAS","text":""},{"location":"11_Erweiterungen/#ohne-hateoas-traditionell","title":"\u274c Ohne HATEOAS (traditionell)","text":"<pre><code>GET /store/supplier/1\n\n{\n  \"sid\": 1,\n  \"name\": \"Meier GmbH\",\n  \"street\": \"Hauptstra\u00dfe 10\",\n  \"postcode\": \"28209\",\n  \"city\": \"Bremen\",\n  \"phone\": \"0421123456\"\n}\n</code></pre> <p>Problem: Client muss selbst wissen, dass er unter <code>/store/article/supplier/1</code> die Artikel finden kann.</p>"},{"location":"11_Erweiterungen/#mit-hateoas-empfohlen","title":"\u2705 Mit HATEOAS (empfohlen)","text":"<pre><code>GET /store/supplier/1\n\n{\n  \"sid\": 1,\n  \"name\": \"Meier GmbH\",\n  \"street\": \"Hauptstra\u00dfe 10\",\n  \"postcode\": \"28209\",\n  \"city\": \"Bremen\",\n  \"phone\": \"0421123456\",\n  \"_links\": {\n    \"self\": {\n      \"href\": \"http://localhost:8080/store/supplier/1\"\n    },\n    \"articles\": {\n      \"href\": \"http://localhost:8080/store/article/supplier/1\"\n    },\n    \"update\": {\n      \"href\": \"http://localhost:8080/store/supplier/1\"\n    },\n    \"delete\": {\n      \"href\": \"http://localhost:8080/store/supplier/1\"\n    }\n  }\n}\n</code></pre> <p>Vorteil: Der Client sieht sofort: - Wo er die Artikel dieses Suppliers findet - Wie er den Supplier aktualisieren kann - Wie er ihn l\u00f6schen kann - Den Link zur Ressource selbst (self)</p>"},{"location":"11_Erweiterungen/#aufgabe-hateoas-implementieren","title":"Aufgabe: HATEOAS implementieren","text":"<p>Beim <code>GET /store/supplier/{id}</code>-Endpunkt soll ein Link enthalten sein, der auf die Artikel des Lieferanten verweist.</p>"},{"location":"11_Erweiterungen/#abhangigkeit-hinzufugen","title":"Abh\u00e4ngigkeit hinzuf\u00fcgen","text":"<pre><code>// build.gradle.kts\nimplementation(\"org.springframework.boot:spring-boot-starter-hateoas\")\n</code></pre>"},{"location":"11_Erweiterungen/#getsupplierdto-erweitern","title":"GetSupplierDto erweitern","text":"<pre><code>import org.springframework.hateoas.RepresentationModel;\n\n@Getter\n@Setter\n@NoArgsConstructor\npublic class GetSupplierDto extends RepresentationModel&lt;GetSupplierDto&gt; {\n    private Long sid;\n    private String name;\n    private String street;\n    private String postcode;\n    private String city;\n    private String phone;\n\n    public static GetSupplierDto toDto(SupplierEntity entity) {\n        GetSupplierDto dto = new GetSupplierDto();\n        dto.setSid(entity.getSid());\n        dto.setName(entity.getName());\n\n        if (entity.getContact() != null) {\n            dto.setStreet(entity.getContact().getStreet());\n            dto.setPostcode(entity.getContact().getPostcode());\n            dto.setCity(entity.getContact().getCity());\n            dto.setPhone(entity.getContact().getPhone());\n        }\n\n        return dto;\n    }\n}\n</code></pre>"},{"location":"11_Erweiterungen/#controller-methode-anpassen","title":"Controller-Methode anpassen","text":"<pre><code>import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.*;\n\n@GetMapping(\"/{id}\")\npublic ResponseEntity&lt;GetSupplierDto&gt; getSupplierById(@PathVariable Long id) {\n    SupplierEntity entity = supplierService.findById(id);\n    GetSupplierDto dto = GetSupplierDto.toDto(entity);\n\n    // HATEOAS-Links hinzuf\u00fcgen\n    dto.add(linkTo(methodOn(SupplierController.class).getSupplierById(id)).withSelfRel());\n    dto.add(linkTo(methodOn(ArticleController.class).getArticlesBySupplier(id)).withRel(\"articles\"));\n\n    return ResponseEntity.ok(dto);\n}\n</code></pre>"},{"location":"11_Erweiterungen/#artikel-endpunkt-im-articlecontroller","title":"Artikel-Endpunkt im ArticleController","text":"<pre><code>@GetMapping(\"/supplier/{supplierId}\")\npublic ResponseEntity&lt;List&lt;GetArticleDto&gt;&gt; getArticlesBySupplier(@PathVariable Long supplierId) {\n    List&lt;ArticleEntity&gt; articles = articleService.findBySupplier(supplierId);\n    List&lt;GetArticleDto&gt; dtos = articles.stream()\n        .map(GetArticleDto::toDto)\n        .collect(Collectors.toList());\n    return ResponseEntity.ok(dtos);\n}\n</code></pre>"},{"location":"11_Erweiterungen/#service-methode-hinzufugen","title":"Service-Methode hinzuf\u00fcgen","text":"<pre><code>// ArticleService\npublic List&lt;ArticleEntity&gt; findBySupplier(Long supplierId) {\n    SupplierEntity supplier = supplierRepository.findById(supplierId)\n        .orElseThrow(() -&gt; new ResourceNotFoundException(\n            \"Supplier not found on Id = \" + supplierId));\n    return new ArrayList&lt;&gt;(supplier.getArticles());\n}\n</code></pre>"},{"location":"11_Erweiterungen/#erwartete-response-mit-hateoas","title":"Erwartete Response mit HATEOAS","text":"<pre><code>{\n  \"sid\": 1,\n  \"name\": \"Meier GmbH\",\n  \"street\": \"Hauptstra\u00dfe 10\",\n  \"postcode\": \"28209\",\n  \"city\": \"Bremen\",\n  \"phone\": \"0421123456\",\n  \"_links\": {\n    \"self\": {\n      \"href\": \"http://localhost:8080/store/supplier/1\"\n    },\n    \"articles\": {\n      \"href\": \"http://localhost:8080/store/article/supplier/1\"\n    }\n  }\n}\n</code></pre>"},{"location":"11_Erweiterungen/#weitere-hateoas-moglichkeiten","title":"Weitere HATEOAS-M\u00f6glichkeiten","text":"<p>Erweitere die Links je nach Bedarf:</p> <pre><code>// Conditionelle Links (nur wenn Aktionen erlaubt sind)\nif (entity.getArticles().isEmpty()) {\n    dto.add(linkTo(methodOn(SupplierController.class).deleteSupplier(id)).withRel(\"delete\"));\n}\n\n// Link zum Aktualisieren\ndto.add(linkTo(methodOn(SupplierController.class).updateSupplier(id, null)).withRel(\"update\"));\n\n// Link zu allen Suppliers\ndto.add(linkTo(methodOn(SupplierController.class).getAllSuppliers()).withRel(\"all-suppliers\"));\n</code></pre>"},{"location":"11_Erweiterungen/#ressourcen","title":"Ressourcen","text":"<ul> <li>Spring HATEOAS Dokumentation: https://spring.io/projects/spring-hateoas</li> <li>Baeldung Tutorial: https://www.baeldung.com/spring-hateoas-tutorial</li> <li>REST Maturity Model (Richardson): HATEOAS entspricht Level 3 (h\u00f6chste REST-Reife)</li> </ul>"}]}